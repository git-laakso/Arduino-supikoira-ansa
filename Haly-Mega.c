//************************************************************************************
//**  
//**  Source name:   C:\Users\laaks\Documents\Haly-Mega.fcfx
//**  Title:         Arduino: Supikoira-ansa
//**  Description:   Supikoira-ansa valvonnalla ja hälytyksellä
//**  Device:        ARD.ATMEGA.ATMEGA2560
//**  
//**  Generated by:  Flowcode v8.2.2.15
//**  Date:          Sunday, April 19, 2020 21:54:04
//**  Project:       https://github.com/git-laakso/Arduino-supikoira-ansa
//**  
//**     NOT FOR COMMERCIAL USE
//**  
//**  https://www.matrixtsl.com
//**  
//************************************************************************************


#define MX_ARD

#define MX_CAL_ARD

#define MX_CLK_SPEED 16000000

#define FCP_NULL Unconnected_Port

#define MX_UART_ID
#define MX_UART_UCSRC

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <avr\io.h>
#include <avr\interrupt.h>
#include <avr\eeprom.h>
#include <avr\wdt.h>


/*========================================================================*\
   Use :Include the type definitions
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\internals.c"





/*========================================================================*\
   Use :panel
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCV_FALSE (0)
#define FCV_TRUE (1)
MX_GLOBAL MX_UINT8 FCV_KILLSOUND;
MX_GLOBAL MX_UINT8 FCV_SWITCHSTATE;
MX_GLOBAL MX_UINT8 FCV_READRESET;


/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05263_switch_base1__ReadState();
void FCD_05263_switch_base1__WaitUntilHigh();
void FCD_05263_switch_base1__WaitUntilLow();

/*========================================================================*\
   Use :KillSound
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_003a1_KillSound__ReadState FCD_05263_switch_base1__ReadState
#define FCD_003a1_KillSound__WaitUntilHigh FCD_05263_switch_base1__WaitUntilHigh
#define FCD_003a1_KillSound__WaitUntilLow FCD_05263_switch_base1__WaitUntilLow

/*========================================================================*\
   Use :shape_rectangle1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :Buzzer1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_0b651_Buzzer1__BuzzerBeep(MX_UINT16 FCL_ONTIME, MX_UINT16 FCL_OFFTIME, MX_UINT8 FCL_NUMBERLOOPS);
void FCD_0b651_Buzzer1__BuzzerOff();
void FCD_0b651_Buzzer1__BuzzerOn();
void FCD_0b651_Buzzer1__BuzzerOnDelay(MX_UINT16 FCL_TIME);

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05262_switch_base__ReadState();
void FCD_05262_switch_base__WaitUntilHigh();
void FCD_05262_switch_base__WaitUntilLow();

/*========================================================================*\
   Use :RESET
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_08271_RESET__ReadState FCD_05262_switch_base__ReadState
#define FCD_08271_RESET__WaitUntilHigh FCD_05262_switch_base__WaitUntilHigh
#define FCD_08271_RESET__WaitUntilLow FCD_05262_switch_base__WaitUntilLow

/*========================================================================*\
   Use :ButtonCtrl
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
MX_UINT8 FCD_05261_switch_base__ReadState();
void FCD_05261_switch_base__WaitUntilHigh();
void FCD_05261_switch_base__WaitUntilLow();

/*========================================================================*\
   Use :sw_push_rnd_pnl1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_0e251_sw_push_rnd_pnl1__ReadState FCD_05261_switch_base__ReadState
#define FCD_0e251_sw_push_rnd_pnl1__WaitUntilHigh FCD_05261_switch_base__WaitUntilHigh
#define FCD_0e251_sw_push_rnd_pnl1__WaitUntilLow FCD_05261_switch_base__WaitUntilLow

/*========================================================================*\
   Use :component_label1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
void FCD_03d91_led_base1__TurnOn();
void FCD_03d91_led_base1__TurnOff();

/*========================================================================*\
   Use :led_5mm1
       :Variable declarations
       :Macro function declarations
\*========================================================================*/
#define FCD_083d1_led_5mm1__TurnOn FCD_03d91_led_base1__TurnOn
#define FCD_083d1_led_5mm1__TurnOff FCD_03d91_led_base1__TurnOff

/*========================================================================*\
   Use :Include the chip adaption layer
\*========================================================================*/
#include "C:\ProgramData\MatrixTSL\FlowcodeV8\CAL\includes.c"


/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05263_switch_base1__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(D, 7))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (0) // 0 > 0

		//Code has been optimised out by the pre-processor
		// #else

		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05263_switch_base1__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(D, 7);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05263_switch_base1__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(D, 7);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (0) // 0 > 0

			//Code has been optimised out by the pre-processor
			// #else

			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :KillSound
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :shape_rectangle1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :Buzzer1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Switches the buzzer on and off automatically to allow for a series of beeps
       :
       :Parameters for macro BuzzerBeep:
       :  OnTime : Length of time in ms the buzzer will remain on
       :  OffTime : Length of time in ms the buzzer will remain off
       :  NumberLoops : Number of times to repeat the sequence. Range 1-255
\*=----------------------------------------------------------------------=*/
void FCD_0b651_Buzzer1__BuzzerBeep(MX_UINT16 FCL_ONTIME, MX_UINT16 FCL_OFFTIME, MX_UINT8 FCL_NUMBERLOOPS)
{
	//Local variable definitions
	MX_UINT8 FCL_COUNT = (0x0);


	while (FCL_COUNT < FCL_NUMBERLOOPS)
	{

		// pin = Polarity
		SET_PORT_PIN(D, 2, 1);

		FCI_DELAYINT_MS(FCL_ONTIME);

		// pin = 1 - Polarity
		SET_PORT_PIN(D, 2, 1 - 1);

		FCI_DELAYINT_MS(FCL_OFFTIME);

		// .count = .count + 1
		FCL_COUNT = FCL_COUNT + 1;


	}

}

/*=----------------------------------------------------------------------=*\
   Use :Switch Off the Buzzer
\*=----------------------------------------------------------------------=*/
void FCD_0b651_Buzzer1__BuzzerOff()
{

	// pin = 1 - Polarity
	SET_PORT_PIN(D, 2, 1 - 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Switch On the Buzzer
\*=----------------------------------------------------------------------=*/
void FCD_0b651_Buzzer1__BuzzerOn()
{

	// pin = Polarity
	SET_PORT_PIN(D, 2, 1);

}

/*=----------------------------------------------------------------------=*\
   Use :Switch the Buzzer on for a fixed amount of time
       :
       :Parameters for macro BuzzerOnDelay:
       :  Time : Time in milliseconds to keep the buzzer on
\*=----------------------------------------------------------------------=*/
void FCD_0b651_Buzzer1__BuzzerOnDelay(MX_UINT16 FCL_TIME)
{

	// pin = Polarity
	SET_PORT_PIN(D, 2, 1);

	FCI_DELAYINT_MS(FCL_TIME);

	// pin = 1 - Polarity
	SET_PORT_PIN(D, 2, 1 - 1);

}


/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05262_switch_base__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (0 != GET_PORT_PIN(D, 6))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (1) // 10 > 0

			while (FCL_DEL_COUNT < 10)
			{

				FCI_DELAYBYTE_MS(1);

				if (0 != GET_PORT_PIN(D, 6))
				{

					// .Return = 1
					FCR_RETVAL = 1;

				} else {

					// .Return = 0
					FCR_RETVAL = 0;

				}

				if (FCR_RETVAL == FCL_OLD_SWITCHVAL)
				{

					// .del_count = .del_count + 1
					FCL_DEL_COUNT = FCL_DEL_COUNT + 1;

				} else {

					// .del_count = 0
					FCL_DEL_COUNT = 0;

				}

				// .old_switchval = .Return
				FCL_OLD_SWITCHVAL = FCR_RETVAL;


			}

		// #else

		//Code has been optimised out by the pre-processor
		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05262_switch_base__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(D, 6);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (1) // 10 > 0

				while (FCL_DEL_COUNT < 10)
				{

					FCI_DELAYBYTE_MS(1);

					// .switchval = pin
					FCL_SWITCHVAL = GET_PORT_PIN(D, 6);

					#if (0) // 0 == 1

					//Code has been optimised out by the pre-processor
					// #else

					#endif

					if (FCL_SWITCHVAL == FCL_OLD_SWITCHVAL)
					{

						// .del_count = .del_count + 1
						FCL_DEL_COUNT = FCL_DEL_COUNT + 1;

					} else {

						// .del_count = 0
						FCL_DEL_COUNT = 0;

					}

					// .old_switchval = .switchval
					FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;


				}

			// #else

			//Code has been optimised out by the pre-processor
			#endif


			if ((FCL_SWITCHVAL == 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05262_switch_base__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(D, 6);

			#if (0) // 0 == 1

			//Code has been optimised out by the pre-processor
			// #else

			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (1) // 10 > 0

				while (FCL_DEL_COUNT < 10)
				{

					FCI_DELAYBYTE_MS(1);

					// .switchval = pin
					FCL_SWITCHVAL = GET_PORT_PIN(D, 6);

					#if (0) // 0 == 1

					//Code has been optimised out by the pre-processor
					// #else

					#endif

					if (FCL_SWITCHVAL == FCL_OLD_SWITCHVAL)
					{

						// .del_count = .del_count + 1
						FCL_DEL_COUNT = FCL_DEL_COUNT + 1;

					} else {

						// .del_count = 0
						FCL_DEL_COUNT = 0;

					}

					// .old_switchval = .switchval
					FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;


				}

			// #else

			//Code has been optimised out by the pre-processor
			#endif


			if ((FCL_SWITCHVAL != 0) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :RESET
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :ButtonCtrl
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :switch_base
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Reads the button state as 0 for released or 1 for pressed
       :Performs debounce if required
       :
       :Returns : MX_UINT8
\*=----------------------------------------------------------------------=*/
MX_UINT8 FCD_05261_switch_base__ReadState()
{
	//Local variable definitions
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;
	MX_UINT8 FCR_RETVAL;


	#if (1)

		if (1 != GET_PORT_PIN(D, 5))
		{

			// .Return = 1
			FCR_RETVAL = 1;

		} else {

			// .Return = 0
			FCR_RETVAL = 0;

		}

		// .del_count = 0
		// .old_switchval = .Return
		FCL_DEL_COUNT = 0;
		FCL_OLD_SWITCHVAL = FCR_RETVAL;

		#if (1) // 10 > 0

			while (FCL_DEL_COUNT < 10)
			{

				FCI_DELAYBYTE_MS(1);

				if (1 != GET_PORT_PIN(D, 5))
				{

					// .Return = 1
					FCR_RETVAL = 1;

				} else {

					// .Return = 0
					FCR_RETVAL = 0;

				}

				if (FCR_RETVAL == FCL_OLD_SWITCHVAL)
				{

					// .del_count = .del_count + 1
					FCL_DEL_COUNT = FCL_DEL_COUNT + 1;

				} else {

					// .del_count = 0
					FCL_DEL_COUNT = 0;

				}

				// .old_switchval = .Return
				FCL_OLD_SWITCHVAL = FCR_RETVAL;


			}

		// #else

		//Code has been optimised out by the pre-processor
		#endif

	#else

	//Code has been optimised out by the pre-processor
	#endif

	return (FCR_RETVAL);

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'high'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05261_switch_base__WaitUntilHigh()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL = (0xff); // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(D, 5);

			#if (1) // 1 == 1

				// .switchval = ! .switchval
				FCL_SWITCHVAL = !FCL_SWITCHVAL;

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (1) // 10 > 0

				while (FCL_DEL_COUNT < 10)
				{

					FCI_DELAYBYTE_MS(1);

					// .switchval = pin
					FCL_SWITCHVAL = GET_PORT_PIN(D, 5);

					#if (1) // 1 == 1

						// .switchval = ! .switchval
						FCL_SWITCHVAL = !FCL_SWITCHVAL;

					// #else

					//Code has been optimised out by the pre-processor
					#endif

					if (FCL_SWITCHVAL == FCL_OLD_SWITCHVAL)
					{

						// .del_count = .del_count + 1
						FCL_DEL_COUNT = FCL_DEL_COUNT + 1;

					} else {

						// .del_count = 0
						FCL_DEL_COUNT = 0;

					}

					// .old_switchval = .switchval
					FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;


				}

			// #else

			//Code has been optimised out by the pre-processor
			#endif


			if ((FCL_SWITCHVAL == 1) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Waits until the switch is in state 'low'
       :The interpretation of 'high' depends on the polarity
\*=----------------------------------------------------------------------=*/
void FCD_05261_switch_base__WaitUntilLow()
{
	//Local variable definitions
	MX_UINT8 FCL_SWITCHVAL; // The state of the pin
	MX_UINT16 FCL_DEL_COUNT;
	MX_UINT8 FCL_OLD_SWITCHVAL;


	#if (1)

		while (1)
		{

			// .switchval = pin
			FCL_SWITCHVAL = GET_PORT_PIN(D, 5);

			#if (1) // 1 == 1

				// .switchval = ! .switchval
				FCL_SWITCHVAL = !FCL_SWITCHVAL;

			// #else

			//Code has been optimised out by the pre-processor
			#endif

			// .del_count = 0
			// .old_switchval = .switchval
			FCL_DEL_COUNT = 0;
			FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;

			#if (1) // 10 > 0

				while (FCL_DEL_COUNT < 10)
				{

					FCI_DELAYBYTE_MS(1);

					// .switchval = pin
					FCL_SWITCHVAL = GET_PORT_PIN(D, 5);

					#if (1) // 1 == 1

						// .switchval = ! .switchval
						FCL_SWITCHVAL = !FCL_SWITCHVAL;

					// #else

					//Code has been optimised out by the pre-processor
					#endif

					if (FCL_SWITCHVAL == FCL_OLD_SWITCHVAL)
					{

						// .del_count = .del_count + 1
						FCL_DEL_COUNT = FCL_DEL_COUNT + 1;

					} else {

						// .del_count = 0
						FCL_DEL_COUNT = 0;

					}

					// .old_switchval = .switchval
					FCL_OLD_SWITCHVAL = FCL_SWITCHVAL;


				}

			// #else

			//Code has been optimised out by the pre-processor
			#endif


			if ((FCL_SWITCHVAL != 1) == 0) break;
		}

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :sw_push_rnd_pnl1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :component_label1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :led_base1
       :Macro implementations
\*========================================================================*/
/*=----------------------------------------------------------------------=*\
   Use :Turn the LED off.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOn()
{

	#if (1)

		// pin = polarity
		SET_PORT_PIN(D, 3, 1);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}

/*=----------------------------------------------------------------------=*\
   Use :Turn the LED on.
\*=----------------------------------------------------------------------=*/
void FCD_03d91_led_base1__TurnOff()
{

	#if (1)

		// pin = 1 - polarity
		SET_PORT_PIN(D, 3, 1 - 1);

	// #else

	//Code has been optimised out by the pre-processor
	#endif

}


/*========================================================================*\
   Use :led_5mm1
       :Macro implementations
\*========================================================================*/

/*========================================================================*\
   Use :panel
       :Macro implementations
\*========================================================================*/


/*========================================================================*\
   Use :Main
\*========================================================================*/
int main()
{
	MCUCR=0x00;
	MCUSR=0x00;
	wdt_disable();

	EIMSK=0x00;


	// Name: Loop, Type: Loop: While 1
	while (1)
	{

		// Name: Connection Point, Type: Connection Point: [B]: B
	FCC_Main_B:
		;

		// Name: Call Component Macro, Type: Call Component Macro: SwitchState=sw_push_rnd_pnl1::ReadState()
		FCV_SWITCHSTATE = FCD_0e251_sw_push_rnd_pnl1__ReadState();

		// Name: Delay, Type: Delay: 5 ms
		FCI_DELAYBYTE_MS(5);

		// Name: Decision, Type: Decision: SwitchState = 1?
		if (FCV_SWITCHSTATE == 1)
		{

			// Name: Loop, Type: Loop: While 1
			while (1)
			{

				// Name: Call Component Macro, Type: Call Component Macro: SwitchState=RESET::ReadState()
				FCV_SWITCHSTATE = FCD_08271_RESET__ReadState();

				// Name: Delay, Type: Delay: 5 ms
				FCI_DELAYBYTE_MS(5);

				// Name: Decision, Type: Decision: SwitchState = 1?
				if (FCV_SWITCHSTATE == 1)
				{

					// Name: Loop, Type: Loop: While 1
					while (1)
					{

						// Name: Connection Point, Type: Connection Point: [C]: C
					FCC_Main_C:
						;

						// Name: Delay, Type: Delay: 5 ms
						FCI_DELAYBYTE_MS(5);

						// Name: Call Component Macro, Type: Call Component Macro: Buzzer1::BuzzerOff()
						FCD_0b651_Buzzer1__BuzzerOff();

						// Name: Delay, Type: Delay: 5 ms
						FCI_DELAYBYTE_MS(5);

						// Name: Call Component Macro, Type: Call Component Macro: led_5mm1::TurnOff()
						FCD_083d1_led_5mm1__TurnOff();

						// Name: Delay, Type: Delay: 5 ms
						FCI_DELAYBYTE_MS(5);

						// Name: Call Component Macro, Type: Call Component Macro: KILLSOUND=KillSound::ReadState()
						FCV_KILLSOUND = FCD_003a1_KillSound__ReadState();

						// Name: Delay, Type: Delay: 5 ms
						FCI_DELAYBYTE_MS(5);

						// Name: Decision, Type: Decision: KILLSOUND = 1?
						if (FCV_KILLSOUND == 1)
						{

							// Name: Goto Connection Point, Type: Goto Connection Point: [B]: B
							goto FCC_Main_B;

						} else {

							// Name: Goto Connection Point, Type: Goto Connection Point: [C]: C
							goto FCC_Main_C;

						}


					}

				} else {

					// Name: Call Component Macro, Type: Call Component Macro: led_5mm1::TurnOn()
					FCD_083d1_led_5mm1__TurnOn();

					// Name: Delay, Type: Delay: 5 ms
					FCI_DELAYBYTE_MS(5);

					// Name: Call Component Macro, Type: Call Component Macro: Buzzer1::BuzzerOn()
					FCD_0b651_Buzzer1__BuzzerOn();

					// Name: Delay, Type: Delay: 5 ms
					FCI_DELAYBYTE_MS(5);

				}


			}

		} else {

			// Name: Connection Point, Type: Connection Point: [A]: A
		FCC_Main_A:
			;

			// Name: Call Component Macro, Type: Call Component Macro: Buzzer1::BuzzerOff()
			FCD_0b651_Buzzer1__BuzzerOff();

			// Name: Delay, Type: Delay: 5 ms
			FCI_DELAYBYTE_MS(5);

			// Name: Call Component Macro, Type: Call Component Macro: led_5mm1::TurnOff()
			FCD_083d1_led_5mm1__TurnOff();

			// Name: Delay, Type: Delay: 500 ms
			FCI_DELAYINT_MS(500);

			// Name: Output, Type: Output: 1 -> D6
			SET_PORT_PIN(D,6,(1));

			// Name: Delay, Type: Delay: 500 ms
			FCI_DELAYINT_MS(500);

			// Name: Output, Type: Output: 0 -> D6
			SET_PORT_PIN(D,6,(0));

			// Name: Delay, Type: Delay: 500 ms
			FCI_DELAYINT_MS(500);

			// Name: Delay, Type: Delay: 5 ms
			FCI_DELAYBYTE_MS(5);

		}


	}

	mainendloop: goto mainendloop;
}



/*========================================================================*\
   Use :Interrupt
\*========================================================================*/




